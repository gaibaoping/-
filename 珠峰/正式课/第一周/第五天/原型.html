<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script type="text/javascript">
    //类都是函数数据类型的，它是一个普通的函数还是一个类，取决于执行的时候是否使用了new这个关键词，Fn()这就是一个普通的函数，new Fn()这就是一个类，我们相当于创建了类的一个实例
    //f1是Fn这个类的一个实例-->f1 instanceof Fn-->true
    function Fn(){
        //this是当前的实例f1
        this.name='珠峰';//f1.name='珠峰' 给当前的实例增加一个叫做name的属性，属性值是'珠峰'
    }
    var f1=new Fn();
    /*
    * new Fn/new Fn()
    *  -->只有使用new创建类实例的时候，如果不需要传递参数的话，那么小括号可以不加
    *  -->当new Fn的时候，此时的Fn就不仅仅是普通函数了，他还是一个类，f1是这个类的一个实例（所有的类都是函数数据类型的，所有的实例都是对象数据类型的）
    *  -->当new Fn的时候，首先Fn会像普通函数一样执行，形成一个私有作用域，然后给形参赋值，在然后进行私有作用域中的预解释；相对于传统的函数，会在函数体中代码执行之前”浏览器默认创建一个对象数据类型的值，而默认创建的这个对象就是我们的实例，而且此时函数体当中出现的this就是默认创建的这个实例，而出现的this.xxx=xxx都是在给当前的实例增加私有的属性，最后浏览器会默认的把创建的对象实例返回到外面，所以在外面定义一个var f=...中的f就是当前类的一个实例“
    * */
    console.log(f1.name);
    console.log(f1 instanceof Fn);//用来检测f1是否是Fn这个类的一个实例（它的本身意思就是用来检测某个实例是否属于这个类）
    console.log(f1.hasOwnProperty('name'));

    function Fn(){
        var n=10;//n是当前作为一个普通函数执行，形成的私有作用域中的一个私有变量，和当前类的实例是没有必然的联系的，只有this.xxx=xxx才相当于在给当前的实例扩展私有属性（因为构造函数模式中的this就是当前类的一个实例）
        this.index=Math.pow(n,2);
        //在构造函数的模式当中，浏览器会默认把创建的实例返回，所以外面的f是当前的实例
        //如果我们自己在加上return
        //返回的是一个基本数据类型：不会对最后的结果产生的任何的影响
        //返回的是一个引用数据类型：自己返回的结果会把默认返回的实例覆盖掉，此时外面的接收的f就不再是Fn的实例了
        //return {
       //     name:'珠峰'
       // };
    }
    var f=new Fn();
    console.log(f.index);//100
    console.log(f.n);//undefined 说明n不是当前实例的一个属性 console.log('n' in f);-->false
</script>